"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3129],{4249:(e,d,o)=>{o.r(d),o.d(d,{data:()=>n});const n={key:"v-104d8005",path:"/articles/Node/NodeJS%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html",title:"NodeJS 安装和使用",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"了解 Node",slug:"了解-node",children:[]},{level:2,title:"Windows 命令",slug:"windows-命令",children:[]},{level:2,title:"Mac 命令",slug:"mac-命令",children:[]},{level:2,title:"进程和线程：",slug:"进程和线程",children:[]},{level:2,title:"安装 node.js",slug:"安装-node-js",children:[]},{level:2,title:"让 node.js 跑起来",slug:"让-node-js-跑起来",children:[]},{level:2,title:"Node.js 的模块发开发",slug:"node-js-的模块发开发",children:[]}],filePathRelative:"articles/Node/NodeJS安装和使用.md",git:{}}},6526:(e,d,o)=>{o.r(d),o.d(d,{default:()=>c});var n=o(6252);const s=(0,n.uE)('<h1 id="nodejs-安装和使用" tabindex="-1"><a class="header-anchor" href="#nodejs-安装和使用" aria-hidden="true">#</a> NodeJS 安装和使用</h1><h2 id="了解-node" tabindex="-1"><a class="header-anchor" href="#了解-node" aria-hidden="true">#</a> 了解 Node</h2><p>NodeJS :主要应用于开发服务器，做数据 API ,设计路由，和前端的主要区别在于，前端主要负责效果和交互、 node.js 是追求性能极致的产物，主要的三个特点是： <strong>单线程、Non-blocking I/O、Event Driven</strong> Nodejs 和其他后端语言的不同：</p><ol><li>采用单线程， 所以</li><li>需要非阻塞 I/O，所以</li><li>需要事件驱动。 极大地提高了 CPU 的利用率：</li><li>node 没有自己的语法，使用 V8 引擎，用的是 js，V8 引擎解析 js，效率非常高。并且 V8 中很多东西都是异步的，，Node 就是站在巨人的肩膀上，把 V8 中的一些功能一直到服务器上</li><li>没有 web 容器 就是安装配置完成之后，也么有一个根目录。（使用路由）</li><li>模块：在 Node.js 中，以模块为单位划分所有的功能，并且提供了一个完成的模块加载机制，我们可以将应用程序划分为各个不同的部分。</li></ol><h2 id="windows-命令" tabindex="-1"><a class="header-anchor" href="#windows-命令" aria-hidden="true">#</a> <strong>Windows 命令</strong></h2><p>常用命令： <code>dir</code> 列出当下目录下面的所有文件 <code>cd</code> 进入指定的目录 <code>md</code> 创建文件夹 <code>rd</code> 删除文件夹 <code>cd..</code> 返回上级目录</p><p><img src="https://gitee.com/zhangningle/imgs/raw/master/blog/Node/nodejs-4.png" alt="nodejs-4"></p><h2 id="mac-命令" tabindex="-1"><a class="header-anchor" href="#mac-命令" aria-hidden="true">#</a> <strong>Mac 命令</strong></h2><p><code>cd ~</code>进入我们的家目录 <code>ls</code> 列出当下目录下面的所有文件 <code>cd 目录名</code> 进入指定的目录 <code>touch 文件名.html</code>创建一后缀是 html 的文件或者一次<code>touch a.txt b.html</code>一次创建多个文件 <code>mkdir 文件夹名</code> 新建一个文件夹或者一次<code>mkdir a b c</code>新建三个文件夹 <code>rm 文件/文件夹</code>删除文件/文件夹 <code>less index.html</code>查看文本文件内容 <code>pwd</code>看看自己在哪个目录下 <code>man</code> 查看某个命令的详情 cd.. 返回上级目录</p><p><strong>小技巧</strong> 用 Tab 键自动补齐命令 比如想到 /System 目录中去，输入 cd /Sy 然后按一下 Tab 键，命令就会自动补齐成 cd /System 操作带名字中带有空格的文件和目录 空格在命令中写成 空格， 比如要进入 My Documents，命令为 cd My Documents</p><h2 id="进程和线程" tabindex="-1"><a class="header-anchor" href="#进程和线程" aria-hidden="true">#</a> 进程和线程：</h2><p>1.进程 系统进行资源分配和调度的基本单位 操作系统的基础，我们写的代码都是放在进程里的 相当于工厂的车间 如：任务管理器 2.线程 九三级的最小计量单位 负责执行进程中的程序，相当于车间里的操作工人， 单线程： js 是单线程，时间片分割 多线程： 根据任务决定开起几条线程（耗内存） Node 服务器： 单线程，但很健壮，后台拥有一个 I/O 线程池进行调度。分布式服务器部署。</p><p><img src="https://gitee.com/zhangningle/imgs/raw/master/blog/Node/nodejs-5.png" alt="nodejs-5"></p><h2 id="安装-node-js" tabindex="-1"><a class="header-anchor" href="#安装-node-js" aria-hidden="true">#</a> 安装 node.js</h2><p><img src="https://gitee.com/zhangningle/imgs/raw/master/blog/Node/nodejs-6.png" alt="nodejs-6"></p>',15),t={href:"https://nodejs.org/en/download/",target:"_blank",rel:"noopener noreferrer"},a=(0,n.Uk)("node.js 下载"),r=(0,n.Uk)(" 有些可能需要配置"),i=(0,n._)("strong",null,"全局环境变量",-1),l=(0,n.uE)('<p><img src="https://gitee.com/zhangningle/imgs/raw/master/blog/Node/nodejs-7.png" alt="nodejs-7"></p><p>node -v 查看版本号</p><p>node 进入 node 环境，在这个环境中可以执行 JavaScript 语句</p><h2 id="让-node-js-跑起来" tabindex="-1"><a class="header-anchor" href="#让-node-js-跑起来" aria-hidden="true">#</a> 让 node.js 跑起来</h2><p>跑起来 node.js 1.node 命令行下写 js 代码 2.新建.js 文件 &gt; cd 到指定目录 &gt; node index.js</p><p><img src="https://gitee.com/zhangningle/imgs/raw/master/blog/Node/nodejs-8.png" alt="nodejs-8"></p><p>建议使用最新的编辑器 有代码提示</p><h2 id="node-js-的模块发开发" tabindex="-1"><a class="header-anchor" href="#node-js-的模块发开发" aria-hidden="true">#</a> Node.js 的模块发开发</h2><p>Node 需要模块化开发： 问题： js 缺乏模块化的开发 解决：后来出现了 commonJs （内部） 和 npm（外部 包管理系统）它提供了模块的复用和引用,</p><p>CommonJs 的出现 主要是为了弥补 JavaScript 没有模块化开发标准的缺陷，</p><p>CommonJS 对模块化的定义：</p><ol><li>模块引用 require（“路径”） 2.模块定义 3.模块表识</li></ol><p><img src="https://gitee.com/zhangningle/imgs/raw/master/blog/Node/nodejs-9.png" alt="nodejs-9"></p><p>总结： 1.从文件的角度看，每个 js 文件就是一个模块，从结构看，多个 js 文件之间可以相互 require，共同实现一个功能，整体上也是一个模块。 2.在 Node.js 中，一个模块中的定义的变量、函数等。都只能在这个文件内部有效；当需要从此文件外部引用这些变量、函数时，必须使用 exports 进行暴露，然后使用 require 引用。</p><p>A：我需要引用你 &gt;&gt; require B B: 那好 &gt;&gt; 我暴露</p><p>13 课至 17 课笔记 视频地址：https://study.163.com/course/courseMain.htm?courseId=1005269026</p>',16),c={render:function(e,d){const o=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[s,(0,n._)("p",null,[(0,n._)("a",t,[a,(0,n.Wm)(o)]),r,i]),l],64)}}}}]);