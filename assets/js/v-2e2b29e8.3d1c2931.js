"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5897],{6615:(e,r,l)=>{l.r(r),l.d(r,{data:()=>i});const i={key:"v-2e2b29e8",path:"/articles/Vue/Vue3%E5%AF%B9%E6%AF%94Vue2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96.html",title:"Vue2 VS Vue3",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"响应式",slug:"响应式",children:[]},{level:2,title:"管理方式",slug:"管理方式",children:[]},{level:2,title:"性能优化",slug:"性能优化",children:[]},{level:2,title:"总结",slug:"总结",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],filePathRelative:"articles/Vue/Vue3对比Vue2有哪些变化.md",git:{}}},6121:(e,r,l)=>{l.r(r),l.d(r,{default:()=>g});var i=l(6252);const t=(0,i.uE)('<h1 id="vue2-vs-vue3" tabindex="-1"><a class="header-anchor" href="#vue2-vs-vue3" aria-hidden="true">#</a> Vue2 VS Vue3</h1><h2 id="响应式" tabindex="-1"><a class="header-anchor" href="#响应式" aria-hidden="true">#</a> 响应式</h2><p>Vue3 使用 Proxy 进行的响应式，Proxy 相比于 defineProperty 的优势，Object.defineProperty() 的问题主要有三个：</p><ul><li>不能监听数组的变化</li><li>必须遍历对象的每个属性</li><li>必须深层遍历嵌套的对象</li></ul><p>Proxy 在 ES2015 规范中被正式加入，它有以下几个特点：</p><ul><li>针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题</li><li>支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。</li></ul><p>除了上述两点之外，Proxy 还拥有以下优势： Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富 Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。</p><h2 id="管理方式" tabindex="-1"><a class="header-anchor" href="#管理方式" aria-hidden="true">#</a> 管理方式</h2><ul><li>代码管理方式 <ul><li>Vue2 的核心代码在 src 目录下，使用 rollup 管理。</li><li>Vue3 使用 monorepo 管理 packages ，目录结构更清晰。</li></ul></li><li>类型管理方式 <ul><li>Vue2 使用的 Flow,Facebook 维护的静态检查工具，已烂尾</li><li>Vue3 使用 TypeScript 重构了整个项目，拥抱 TS 生态</li></ul></li></ul><h2 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h2><p><strong>源码体积优化</strong></p><ul><li>首先，移除一些冷门的 feature（比如 filter、inline-template 等）；</li><li>其次，引入 tree-shaking 的技术，减少打包体积。 使用 tree-shaking 的原理就是利用 ES5 的模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块，并打上标记，然后在打包的时候，不打包这些没用到的模块，从而减少项目体积。 <strong>数据劫持优化</strong> Vue2 使用的 Object.defineProperty 的 getter/setter 对对象的属性进行的数据劫持，但是存在一些缺点，比如对于数组的检测支持并不是很好、不能检测对象属性的添加和删除（虽然有$set和$delete，但是还有不太友好）。 Vue3 使用 Proxy，它劫持的是整个对象，对于对象属性的增加和删除都能检测到</li></ul><p><strong>编译优化</strong> 通过编译阶段对静态模板的分析，编译成 Block Tree，简单来说就是把每个节点都打上一个标记，然后 diff 的时候好判断是否需要更新这个节点，这是一个非常大的性能突破。</p><p><strong>语法优化</strong> 提供 composition API，他的优点包括</p><ul><li>优化逻辑组织（对比 OptionsAPI），将某个逻辑关注点项目的代码都放在一个函数里，<strong>减少反复横挑</strong></li><li>逻辑复用，Vue2 需要使用 mixin 来处理，Vue3 直接使用函数复用</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>使用 proxy 代替 getter/setter</li><li>使用 typescipt 代替 flow 管理类型</li><li>引入 tree-shaking 减少代码体积</li><li>使用 composition 组织状态</li><li>使用 monorepo 代替 rollup 管理代码</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',18),n={href:"https://github.com/vuejs/vue-next",target:"_blank",rel:"noopener noreferrer"},a=(0,i.Uk)("vue-next for GitHub"),u={href:"https://composition-api.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},o=(0,i.Uk)("Vue3 使用文档"),h={href:"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=326#/content",target:"_blank",rel:"noopener noreferrer"},s=(0,i.Uk)("拉钩教育-黄秩-Vue3 源码解析"),d={href:"https://juejin.im/post/5d977f47e51d4578453274b3",target:"_blank",rel:"noopener noreferrer"},p=(0,i.Uk)("掘金 - Vue 3 源码导读"),c={href:"https://hkc452.github.io/slamdunk-the-vue3/main/",target:"_blank",rel:"noopener noreferrer"},f=(0,i.Uk)("Vue3.0 源码解读-blog"),g={render:function(e,r){const l=(0,i.up)("OutboundLink");return(0,i.wg)(),(0,i.iD)(i.HY,null,[t,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i._)("a",n,[a,(0,i.Wm)(l)])]),(0,i._)("li",null,[(0,i._)("a",u,[o,(0,i.Wm)(l)])]),(0,i._)("li",null,[(0,i._)("a",h,[s,(0,i.Wm)(l)])]),(0,i._)("li",null,[(0,i._)("a",d,[p,(0,i.Wm)(l)])]),(0,i._)("li",null,[(0,i._)("a",c,[f,(0,i.Wm)(l)])])])],64)}}}}]);