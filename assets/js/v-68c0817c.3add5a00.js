"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2445],{3925:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-68c0817c",path:"/computer-base/LeetCode/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"描述",slug:"描述",children:[]},{level:2,title:"解法",slug:"解法",children:[{level:3,title:"栈",slug:"栈",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]}],filePathRelative:"computer-base/LeetCode/有效的括号.md",git:{}}},3288:(n,s,a)=>{a.r(s),a.d(s,{default:()=>u});var p=a(6252);const e=(0,p.uE)('<h2 id="描述" tabindex="-1"><a class="header-anchor" href="#描述" aria-hidden="true">#</a> 描述</h2><p>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。</p><p>示例 1：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：s = &quot;()&quot;\n输出：true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例 2：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：s = &quot;()[]{}&quot;\n输出：true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例 3：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：s = &quot;(]&quot;\n输出：false\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例 4：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：s = &quot;([)]&quot;\n输出：false\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例 5：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入：s = &quot;{[]}&quot;\n输出：true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>',14),t=(0,p.Uk)("题目："),l={href:"https://leetcode-cn.com/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"},o=(0,p.Uk)("有效的括号"),c=(0,p.uE)('<h2 id="解法" tabindex="-1"><a class="header-anchor" href="#解法" aria-hidden="true">#</a> 解法</h2><h3 id="栈" tabindex="-1"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h3><p>利用栈先进后出的特性，依次左储存括号，每当遇到右括号时，就去匹配响应的左括号，匹配成功则出栈，最后栈为空则表示匹配正确。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> strArr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n  <span class="token keyword">let</span> flagArr <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token string">&quot;(&quot;</span><span class="token operator">:</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">,</span>\n    <span class="token string">&quot;{&quot;</span><span class="token operator">:</span> <span class="token string">&quot;}&quot;</span><span class="token punctuation">,</span>\n    <span class="token string">&quot;[&quot;</span><span class="token operator">:</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存放临时括号</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> left <span class="token operator">=</span> strArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>flagArr<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>strArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> flagArr<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> stack<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token string">&quot;()[]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>思路：</p><ol><li>使用 split 将传入的字符串转为数组，拿到长度，并建立一个左右括号的映射。</li><li>建立 stack 空栈，用于储蓄括号。</li><li>for 这个数组 <ol><li>判断出现左括号时，将当前左括号入栈。</li><li>判断非左括号（也就是右括号时），将最后入栈的左括号拿来比对是否匹配 <ol><li>匹配则出栈，然后继续 for</li><li>不匹配就 return false</li></ol></li><li>for 结束后，判断栈为空，就 return true</li></ol></li></ol><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>用到了栈的一些特性，用数组模拟栈先入后出的原则。然后通过匹配得出结果。</p>',10),u={render:function(n,s){const a=(0,p.up)("OutboundLink");return(0,p.wg)(),(0,p.iD)(p.HY,null,[e,(0,p._)("p",null,[t,(0,p._)("a",l,[o,(0,p.Wm)(a)])]),c],64)}}}}]);