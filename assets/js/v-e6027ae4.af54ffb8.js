"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1689],{3749:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-e6027ae4",path:"/computer-base/LeetCode/%E7%88%AC%E6%A5%BC%E6%A2%AF.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"描述",slug:"描述",children:[]},{level:2,title:"解法",slug:"解法",children:[{level:3,title:"递归",slug:"递归",children:[]},{level:3,title:"动态规划",slug:"动态规划",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]}],filePathRelative:"computer-base/LeetCode/爬楼梯.md",git:{}}},7111:(n,s,a)=>{a.r(s),a.d(s,{default:()=>r});var p=a(6252);const e=(0,p.uE)('<h2 id="描述" tabindex="-1"><a class="header-anchor" href="#描述" aria-hidden="true">#</a> 描述</h2><p>假设你正在爬楼梯。需要 n  阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>示例 2：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div>',8),t=(0,p.Uk)("题目："),l={href:"https://leetcode-cn.com/problems/climbing-stairs/",target:"_blank",rel:"noopener noreferrer"},o=(0,p.Uk)("爬楼梯"),c=(0,p.uE)('<h2 id="解法" tabindex="-1"><a class="header-anchor" href="#解法" aria-hidden="true">#</a> 解法</h2><h3 id="递归" tabindex="-1"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h3><p>通过题目描述，可以推算出规律如下：</p><ul><li>1 节台阶：有 1 种方法 <ul><li>1</li></ul></li><li>2 节台阶：有 2 种方法 <ul><li>1+1</li><li>2</li></ul></li><li>3 节台阶：有 3 种方法 <ul><li>1+1+1</li><li>1+2</li><li>2+1</li></ul></li><li>4 节台阶：有 5 种方法 <ul><li>1+1+1+1</li><li>1+2+1</li><li>1+1+2</li><li>2+1+1</li><li>2+2</li></ul></li><li>5 节台阶：有 8 种方法 <ul><li>1+1+1+1+1</li><li>1+1+1+2</li><li>....</li></ul></li></ul><p>如此是可以找到规律的，出 1、2 节台阶外，之后的台阶是前两个台阶方法的总和，是一个典型的斐波那契数列。</p><p>因此可以使用递归的方式解答：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">2</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> n<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>但是 LeetCode 提交如上代码会不通过，因为数大的时候运行时间过长，所以需要进一步优化。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">2</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> n<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">let</span> memory <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    memory<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> memory<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> memory<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> memory<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们可以使用数组模拟递归的执行，将台阶数设为数据的索引，方法为数据，以 0-3 为基础，将 n 之前的方法全部推算出来，然后 for 出来即可，这种方法也称为<strong>记忆递归法</strong>。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划" aria-hidden="true">#</a> 动态规划</h3><p>我们用 f(x) 表示爬到第 x 级台阶的方法数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>f(x)=f(x−1)+f(x−2)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>也就是说当我们求 x 级台阶的方法数的时候，其实只需要知道 x-1 和 x-2 的方法数就可以了，以此类推。</p><p>边界条件：从 0 级台阶到 0 级台阶只有一种方法。</p><p>因此，我们可以使用滚动数组实现这一次方法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">climbStairs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// x-2 方法数</span>\n    q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// x-1 的方法数</span>\n    r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当前 n 方法数</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    p <span class="token operator">=</span> q<span class="token punctuation">;</span>\n    q <span class="token operator">=</span> r<span class="token punctuation">;</span>\n    r <span class="token operator">=</span> p <span class="token operator">+</span> q<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> r<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt="步骤示意图"></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>斐波那契数列的通用公式：f(x) = f(x-1) + f(x-2)</p><p>动态规划的思想：动态规划是把一个大问题拆解成一堆小问题的思想，</p><p>遇到问题不要慌，在纸上画画，然后一步一步的观察规律，总结规律。</p>',26),r={render:function(n,s){const a=(0,p.up)("OutboundLink");return(0,p.wg)(),(0,p.iD)(p.HY,null,[e,(0,p._)("p",null,[t,(0,p._)("a",l,[o,(0,p.Wm)(a)])]),c],64)}}}}]);