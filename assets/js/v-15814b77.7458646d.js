"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5095],{827:(e,l,t)=>{t.r(l),t.d(l,{data:()=>a});const a={key:"v-15814b77",path:"/articles/Performance/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html",title:"浏览器缓存机制",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"HTTP 缓存机制",slug:"http-缓存机制",children:[]},{level:2,title:"浏览器本地储存",slug:"浏览器本地储存",children:[]},{level:2,title:"Cookie",slug:"cookie",children:[{level:3,title:"优点",slug:"优点",children:[]},{level:3,title:"缺点",slug:"缺点",children:[]}]},{level:2,title:"Web Storage",slug:"web-storage",children:[{level:3,title:"localStorage",slug:"localstorage",children:[]},{level:3,title:"sessionStorage",slug:"sessionstorage",children:[]},{level:3,title:"使用",slug:"使用",children:[]}]},{level:2,title:"indexedDB",slug:"indexeddb",children:[]},{level:2,title:"PWA",slug:"pwa",children:[]}],filePathRelative:"articles/Performance/浏览器缓存机制.md",git:{}}},5843:(e,l,t)=>{t.r(l),t.d(l,{default:()=>v});var a=t(6252);const r=(0,a.uE)('<h1 id="浏览器缓存机制" tabindex="-1"><a class="header-anchor" href="#浏览器缓存机制" aria-hidden="true">#</a> 浏览器缓存机制</h1><p>前端缓存分为网络(HTTP)缓存和浏览器本地储存。</p><p><img src="https://i.loli.net/2021/01/08/IKcNGloQrzUZ2ER.png" alt="http-cache.jpg"></p><h2 id="http-缓存机制" tabindex="-1"><a class="header-anchor" href="#http-缓存机制" aria-hidden="true">#</a> HTTP 缓存机制</h2>',4),i=(0,a.Uk)("请移步："),d=(0,a.Uk)("网络协议-HTTP-缓存缓存机制"),o=(0,a.uE)('<h2 id="浏览器本地储存" tabindex="-1"><a class="header-anchor" href="#浏览器本地储存" aria-hidden="true">#</a> 浏览器本地储存</h2><p>我们先来通过表格学习下这几种存储方式的区别</p><table><thead><tr><th>特性</th><th>Cookie</th><th>localStorage</th><th>sessionStorage</th><th>indexedDB</th></tr></thead><tbody><tr><td>数据声明周期</td><td>一般由服务器生成，可以设置过期时间</td><td>除非被清理，否在一直存在</td><td>页面关闭就清理</td><td>除非被清理，否在一直存在</td></tr><tr><td>数据储存大小</td><td>4k</td><td>5M 左右</td><td>5M 左右</td><td>理论无限</td></tr><tr><td>与服务端通信</td><td>请求时会携带在 Http 的 header 中，对于请求性能稍有影响</td><td>不参与</td><td>不参与</td><td>不参与</td></tr></tbody></table><h2 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> Cookie</h2><p>主要用于存储一下用户相关的信息，如登录、权限、token 等，但是不宜过大，因为每次 http 请求都会带上，所以会稍微影响性能。 对于 cookie 来说，还需要注意一些安全性。</p><p>| 属性 | 作用 | | value | 如何用于保护用户登录态，应该将值加密 | | http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击 | | secure | 只能在协议为 HTTPS 的请求中携带 | | same-site | 规定浏览器不能再跨域请求中携带 Cookie，减少 CSRF 攻击 |</p><p>Cookie 的本职工作并非是本地存储，而是“维持状态”。 因为 HTTP 是一种无状态的协议，也就是说，客户端请求一次，服务端就响应一次，中间没有留下任何信息。 就像一个经常和你聊天的朋友，天南地北的都什么都聊，可每次你都不知道你们上一次聊得是什么，以及他叫什么名字。 那怎么办才能让他知道我是我呢？ 这时候就需要 Cookie 了，Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。 它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态，也就可以证明我是谁了。 Cookie 是以键值对的形式存储的。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ul><li>后端设置</li><li>解决鉴权问题</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ul><li>只有 4m，太小</li><li>过量的 Cookie 会带来巨大的性能浪费</li><li>不能跨域</li></ul><h2 id="web-storage" tabindex="-1"><a class="header-anchor" href="#web-storage" aria-hidden="true">#</a> Web Storage</h2><h3 id="localstorage" tabindex="-1"><a class="header-anchor" href="#localstorage" aria-hidden="true">#</a> localStorage</h3><ul><li>本地永久储存，除非手动清除，否在一直存在</li><li>大小：5M 左右</li><li>用于储存稳定的资源：如 CSS、js、小图等。</li></ul><h3 id="sessionstorage" tabindex="-1"><a class="header-anchor" href="#sessionstorage" aria-hidden="true">#</a> sessionStorage</h3><ul><li>页面回话存储，关闭页面自动清除。</li><li>大小：5M 左右</li><li>用于临时的数据：如 token、个人信息、权限、购物车信息等</li></ul><p>需要注意的是localStorage和sessionStorage都是遵循同源策略的：</p><ul><li><ul><li>localStorage只要在相同的协议、相同的主机名（二级域名也不行）、相同的端口下，就能读取/修改到同一份localStorage数据。</li><li>sessionStorage比localStorage更严苛一点，除了协议、主机名（二级域名也不行）、端口外，还要求在同一窗口（也就是浏览器的标签页）下。</li></ul></li></ul><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><ul><li>存储数据：setItem()<br><code>localStorage.setItem(&#39;user_name&#39;, &#39;xiuyan&#39;)</code></li><li>读取数据： getItem()<br><code>localStorage.getItem(&#39;user_name&#39;)</code></li><li>删除某一键名对应的数据： removeItem()<br><code>localStorage.removeItem(&#39;user_name&#39;)</code></li><li>清空数据记录：clear()<br><code>localStorage.clear()</code></li></ul><h2 id="indexeddb" tabindex="-1"><a class="header-anchor" href="#indexeddb" aria-hidden="true">#</a> indexedDB</h2><p>IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。</p><p>理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>',23),h=(0,a.Uk)("本人用的也不是很多，具体用法可以参考："),n={href:"http://www.ruanyifeng.com/blog/2018/07/indexeddb.html",target:"_blank",rel:"noopener noreferrer"},s=(0,a.Uk)("浏览器数据库 IndexedDB 入门教程"),c=(0,a._)("h2",{id:"pwa",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#pwa","aria-hidden":"true"},"#"),(0,a.Uk)(" PWA")],-1),u=(0,a._)("p",null,"PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。",-1),p=(0,a._)("p",null,"这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。 这组文档和指南告诉您有关 PWA 的所有信息。",-1),g=(0,a._)("p",null,"其实我的理解，就是在浏览器或者其他客户端应用缓存一个 webapp，一次使用，就将代码都缓存到本地，再次打开无需重复加载。",-1),b=(0,a._)("p",null,"是不是觉得很熟悉，这不就是微信小程序吗？",-1),k=(0,a._)("p",null,"其实现在的微信小程序、快应用都算是一种 PWA 的实现。",-1),m=(0,a._)("p",null,"比如：vuePress 就支持转 PWA 应用",-1),f=(0,a.Uk)("参考："),S={href:"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps",target:"_blank",rel:"noopener noreferrer"},x=(0,a.Uk)("MDN-PWA"),v={render:function(e,l){const t=(0,a.up)("RouterLink"),v=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[r,(0,a._)("p",null,[i,(0,a.Wm)(t,{to:"/computer-base/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"},{default:(0,a.w5)((()=>[d])),_:1})]),o,(0,a._)("p",null,[h,(0,a._)("a",n,[s,(0,a.Wm)(v)])]),c,u,p,g,b,k,m,(0,a._)("p",null,[f,(0,a._)("a",S,[x,(0,a.Wm)(v)])])],64)}}}}]);