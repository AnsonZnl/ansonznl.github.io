"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1810],{9917:(e,t,a)=>{a.r(t),a.d(t,{data:()=>i});const i={key:"v-14cae6ef",path:"/articles/Vue/Vuex%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html",title:"Vuex 原理解析",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"特点",slug:"特点",children:[]},{level:2,title:"Vuex 核心思想",slug:"vuex-核心思想",children:[]},{level:2,title:"Vuex 初始化",slug:"vuex-初始化",children:[{level:3,title:"安装",slug:"安装",children:[]},{level:3,title:"Store 实例化",slug:"store-实例化",children:[]},{level:3,title:"初始化模块",slug:"初始化模块",children:[]},{level:3,title:"安装模块",slug:"安装模块",children:[]},{level:3,title:"初始化 store._vm",slug:"初始化-store-vm",children:[]},{level:3,title:"总结",slug:"总结",children:[]}]},{level:2,title:"API",slug:"api",children:[{level:3,title:"数据获取",slug:"数据获取",children:[]},{level:3,title:"数据存储",slug:"数据存储",children:[]},{level:3,title:"语法糖",slug:"语法糖",children:[]},{level:3,title:"动态更新模块",slug:"动态更新模块",children:[]},{level:3,title:"总结",slug:"总结-1",children:[]},{level:3,title:"最佳实践",slug:"最佳实践",children:[]},{level:3,title:"参考",slug:"参考",children:[]}]}],filePathRelative:"articles/Vue/Vuex原理解析.md",git:{}}},8939:(e,t,a)=>{a.r(t),a.d(t,{default:()=>g});var i=a(6252);const r=(0,i.uE)('<h1 id="vuex-原理解析" tabindex="-1"><a class="header-anchor" href="#vuex-原理解析" aria-hidden="true">#</a> Vuex 原理解析</h1><p>核心思想：store，基于 Vue 响应式的全局对象。</p><ul><li>Vuex 的状态储存是响应式的，当 Vue 组件从 store 中去读状态时，若 store 中状态发生变化，那么相应的组件也会得到更新。</li><li>你不能直接改变 store 的值，改变 store 中的状态的唯一途径就是显式的提交，这样可以方便我们跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好的了解我们的应用。</li></ul><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><ol><li>集中式储存管理应用的所有组件的状态。</li><li>并与相应的规则保证状态以一种可预测的方式改变。 状态管理</li></ol><ul><li>state：驱动应用的数据源</li><li>view：将 state 映射到视图当中</li><li>actions：响应在 view 上的状态变化。</li></ul><p><img src="https://ustbhuangyi.github.io/vue-analysis/assets/vuex.png" alt="单向数据流"></p><h2 id="vuex-核心思想" tabindex="-1"><a class="header-anchor" href="#vuex-核心思想" aria-hidden="true">#</a> Vuex 核心思想</h2><p>store：一个包含大部分状态的容器，他和全局变量的区别有两点不同：</p><ul><li>Vuex 状态时响应式的，数据会驱动视图发生变化。</li><li>你不能直接改变 store，改变的途径只能使用 commit 一个 mutation，因为这样可以方便跟踪每一个状态的变化。</li></ul><p>通过定义和状态隔离的概念并强制遵守一定的规则，会使得代码易于维护。</p><p><img src="https://ustbhuangyi.github.io/vue-analysis/assets/vuex1.png" alt=""></p><h2 id="vuex-初始化" tabindex="-1"><a class="header-anchor" href="#vuex-初始化" aria-hidden="true">#</a> Vuex 初始化</h2><h3 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h3><ul><li>实现一个 install，接受一个 vue 实例</li><li>使用 mixin 在 beforeCreat 中执行 vuexInit 方法</li><li>把 options.store 保存在所有组件的 this.$store 当中。</li></ul><h3 id="store-实例化" tabindex="-1"><a class="header-anchor" href="#store-实例化" aria-hidden="true">#</a> Store 实例化</h3><p>在 import Vuex 后，会实例化其中的 Store 对象，返回 store 实例并传入 new Vue 的 options，也就是 options.store。</p><p>初始化 store._vm 将 getters 和 state 联系起来，利用了 Vue 中的 computed</p><p>通过 key 访问，store。getters 的某个值时，其实就是访问了 store._vm[key]，也就是 computed[key]。</p><h3 id="初始化模块" tabindex="-1"><a class="header-anchor" href="#初始化模块" aria-hidden="true">#</a> 初始化模块</h3><p>Vuex 允许我们将 store 分割成多个模块（module）,每个模块都有自己的 store mutation action getter。</p><p>可以将 store 理解一个 root module，下面的 modules 就是子模块。（树形结构）</p><p>模块管理：注册=》构建=》加载模块=》建立关系</p><h3 id="安装模块" tabindex="-1"><a class="header-anchor" href="#安装模块" aria-hidden="true">#</a> 安装模块</h3><p>初始化之后，对模块中的 state、getters、mutation、actions 做初始化工作。</p><p>执行 installModule</p><ul><li>registerMustion</li><li>registerAction</li><li>registerGetter</li></ul><h3 id="初始化-store-vm" tabindex="-1"><a class="header-anchor" href="#初始化-store-vm" aria-hidden="true">#</a> 初始化 store._vm</h3><p>resetStoreVm</p><ul><li>forEach 所有的值</li><li>将所有的值变成响应式的</li><li>getters 是借助 computed 实现的</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>安装，mixin 在 beforeCreate 中进行 this.$store 的实例化 把 store 想象成一个数据仓库，为了方便管理，将 store 拆分成了一些 modules，每个 moduels 又分别定义了 state,getter,mutations,actions，通过递归+遍历的方式完成了初始化。 为了更好的封装性和复用性，还定义了 namespace 的概念。 最后定义了一个内部的 Vue 实例，用来建立 state 和 getters 的联系，并且可以在严格模式下检测 state 的变化是不是来自外部的，确保求变的 state 的唯一途径就是显式的提交 mutation。</p><h2 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h2><p>store 的 API 分析</p><h3 id="数据获取" tabindex="-1"><a class="header-anchor" href="#数据获取" aria-hidden="true">#</a> 数据获取</h3><p><code>store.state.a.b.xx</code>在 installModule 实现的</p><h3 id="数据存储" tabindex="-1"><a class="header-anchor" href="#数据存储" aria-hidden="true">#</a> 数据存储</h3><p>修改通过 mutation 去修改，通过 commit 方法去提交一个 mutation。 mutation 必须是一个同步函数，用与同步修改 action 类似于 mutation，并且可以包含异步操作。 通过 dispatch 方法提交一个 action。</p><h3 id="语法糖" tabindex="-1"><a class="header-anchor" href="#语法糖" aria-hidden="true">#</a> 语法糖</h3><p>mapState</p><p>mapGetters</p><p>mapMutations</p><p>mapActions</p><h3 id="动态更新模块" tabindex="-1"><a class="header-anchor" href="#动态更新模块" aria-hidden="true">#</a> 动态更新模块</h3><p>通过 store 上提供的一个 registerModule 方法，支持传入一个路径进行动态模块定义。 相应的也提供动态卸载模块的方法，unregisterModule 方法，也是接受接受一个路径。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h3><p>Vuex 提供 API 包括数据的存取、语法糖、模块的动态更新等，值得学习。</p><h3 id="最佳实践" tabindex="-1"><a class="header-anchor" href="#最佳实践" aria-hidden="true">#</a> 最佳实践</h3><p>Vuex 存储的数据是在内存中的，所以页面一刷新数据就消失了。解决方法就是利用浏览器的本地缓存和 Vuex 中做一个中间代理。缓存做为代理方，存储数据，Vuex 作为获取方，从本地缓存中拿去数据。</p><p><strong>缓存方式的选择</strong></p><ul><li>cookie：跟随域名的 cookie，5k,会带在 http 请求上</li><li>sessionStorage：会话储存 5M，页面关闭数据清除</li><li>localStorage：永久储存 5M，不清楚一直存在</li></ul><p>他们的优劣和使用场景不同，localStorage 适合储存不变的数据，比如网站的 logo。sessionStorage 适合存储一些临时的数据，比如个人信息、token。而 cookie 储存较小，而且会带在着 http 请求上，不易过大，但是兼容性较好，比如在微信网页内，只能使用 cookie 进行储存。</p><p><strong>优秀的第三方库</strong></p><p>可以借助第三方库来更方便的操作本地缓存。</p>',54),l={href:"https://github.com/robinvdvleuten/vuex-persistedstate",target:"_blank",rel:"noopener noreferrer"},s=(0,i.Uk)("vuex-persistedstate"),n={href:"https://github.com/js-cookie/js-cookie",target:"_blank",rel:"noopener noreferrer"},o=(0,i.Uk)("js-cookie"),h={href:"https://www.npmjs.com/package/vue-savedata",target:"_blank",rel:"noopener noreferrer"},u=(0,i.Uk)("vue-savedata"),d=(0,i._)("h3",{id:"参考",tabindex:"-1"},[(0,i._)("a",{class:"header-anchor",href:"#参考","aria-hidden":"true"},"#"),(0,i.Uk)(" 参考")],-1),p={href:"https://ustbhuangyi.github.io/vue-analysis/v2/vuex/#%E4%BB%80%E4%B9%88%E6%98%AF-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F-%EF%BC%9F",target:"_blank",rel:"noopener noreferrer"},c=(0,i.Uk)("Vue.js 技术揭秘-Vuex"),g={render:function(e,t){const a=(0,i.up)("OutboundLink");return(0,i.wg)(),(0,i.iD)(i.HY,null,[r,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i._)("a",l,[s,(0,i.Wm)(a)])]),(0,i._)("li",null,[(0,i._)("a",n,[o,(0,i.Wm)(a)])]),(0,i._)("li",null,[(0,i._)("a",h,[u,(0,i.Wm)(a)])])]),d,(0,i._)("ul",null,[(0,i._)("li",null,[(0,i._)("a",p,[c,(0,i.Wm)(a)])])])],64)}}}}]);