"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4854],{2727:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-15519a67",path:"/articles/Vue/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.html",title:"Vue 模板编译原理解析",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"运行版本",slug:"运行版本",children:[]},{level:2,title:"编译过程",slug:"编译过程",children:[{level:3,title:"解析器",slug:"解析器",children:[]},{level:3,title:"优化器",slug:"优化器",children:[]},{level:3,title:"生成代码",slug:"生成代码",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],filePathRelative:"articles/Vue/Vue模板编译原理解析.md",git:{}}},6389:(n,s,a)=>{a.r(s),a.d(s,{default:()=>M});var p=a(6252);const e=(0,p.uE)('<h1 id="vue-模板编译原理解析" tabindex="-1"><a class="header-anchor" href="#vue-模板编译原理解析" aria-hidden="true">#</a> Vue 模板编译原理解析</h1><p>在 Vue 开发过程中，我们通常使用<code>.vue</code>文件进行开发，然后上线时打包成一个<code>js</code>最后在页面中加载然后渲染 DOM。</p><p>那么 他是怎么从<code>.vue</code> 文件编译成<code>.js</code> 的那，中间发生了什么？</p><p><img src="https://i.loli.net/2021/07/19/AWp6kCSvLth74Bj.png" alt="流程图"></p><h2 id="运行版本" tabindex="-1"><a class="header-anchor" href="#运行版本" aria-hidden="true">#</a> 运行版本</h2><p>通常我们利用 vue-cli 去初始化 Vue.js 时，在 Vue 中有两个版本：</p><ul><li><p>Runtime Only</p><ul><li><code>vue.js</code>： 完整版本，包含了模板编译的能力；<br> 我们在借助 vue-cli 生成的项目时，通常需要使用 webpack 的 vue-loader 工具，将<code>.vue</code>文件编译成<code>.js</code>文件，因为他是在编译阶段做的，所以只包含运行时的 Vue.js 代码，因此代码总量体积会比较轻。</li></ul></li><li><p>Runtime + Compiler</p><ul><li><code>vue.runtime.js</code>： 运行时版本，不提供模板编译能力，需要通过 vue-loader 进行提前编译。<br> 如果我们没有对代码做预编译的时候（如 CND 引入时）但又使用 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：</li></ul></li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 需要编译器的版本</span>\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token string">&quot;&lt;div&gt;{{ hi }}&lt;/div&gt;&quot;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 这种情况不需要</span>\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hi<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>因为在 Vue.js 中最终的渲染都是通过 render 函数，如果写 template 属性，则需要在编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。</p><h2 id="编译过程" tabindex="-1"><a class="header-anchor" href="#编译过程" aria-hidden="true">#</a> 编译过程</h2>',10),t=(0,p.Uk)("在 Vue 源码中编译过程这块"),o={href:"https://github1s.com/vuejs/vue/blob/HEAD/src/platforms/web/entry-runtime-with-compiler.js",target:"_blank",rel:"noopener noreferrer"},l=(0,p.Uk)("src/platforms/web/entry-runtime-with-compiler.js"),c=(0,p.Uk)("可以得出编译的三个过程："),u=(0,p.uE)('<ul><li><p>解析器将模板字符串转换成 AST</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>优化语法树</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>生成最最终 <code>render</code> 函数代码字符串</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><h3 id="解析器" tabindex="-1"><a class="header-anchor" href="#解析器" aria-hidden="true">#</a> 解析器</h3><p>编译过程首先是对模板进行解析，生成 element ASTs，他是一种抽象语法树，对于源代码的抽象语法结构的树状表现形式。</p><p>这个过程比较复杂，他会用到大量的正则表达式对字符串解析：</p><p>为了直观的演示<code>parse</code>的过程，我们看一个例子：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>经过 <code>parse</code> 后，生成的 AST 如下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>\n  tag<span class="token operator">:</span> <span class="token string">&quot;div&quot;</span>\n  type<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  staticRoot<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n  <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n  plain<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  parent<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>\n  attrsList<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  attrsMap<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n  children<span class="token operator">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span>\n      tag<span class="token operator">:</span> <span class="token string">&quot;p&quot;</span>\n      type<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n      staticRoot<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n      <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n      plain<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      parent<span class="token operator">:</span> <span class="token punctuation">{</span>tag<span class="token operator">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n      attrsList<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n      attrsMap<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n      children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n          type<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>\n          text<span class="token operator">:</span> <span class="token string">&quot;{{name}}&quot;</span><span class="token punctuation">,</span>\n          <span class="token keyword">static</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n          expression<span class="token operator">:</span> <span class="token string">&quot;_s(name)&quot;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>这个过程是通过分析模板中的字符串，通过正则匹配（如<code>&lt;div&gt;</code>匹配<code>&lt;/div&gt;</code>）来生成的。</p><p>其实模板编译主要是两部分内容，一部分是截取字符串(span、p)，一部分是对截取之后的字符串做解析。</p>',10),i=(0,p.Uk)("没截取一段标签的开头就 push 到栈中，解析到标签的结束就 pop 出来，当所有的字符串都截取没了也就解析完了（参考"),r={href:"https://leetcode-cn.com/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"},k=(0,p.Uk)("leetCode"),d=(0,p.Uk)("）。"),b=(0,p.Uk)("这块挺复杂的，细节太多，参考："),m={href:"https://ustbhuangyi.github.io/vue-analysis/v2/compile/parse.html#%E6%B5%81%E7%A8%8B%E5%9B%BE",target:"_blank",rel:"noopener noreferrer"},g=(0,p.Uk)("Vue.js 技术揭秘-parse"),h=(0,p.uE)('<h3 id="优化器" tabindex="-1"><a class="header-anchor" href="#优化器" aria-hidden="true">#</a> 优化器</h3><p>优化器的目标是找出那些事静态节点并打上标记，而静态节点指的是 DOM 不需要发生改变的节点，如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>我不会发生变化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>静态节点有两个好处：</p><ol><li>每次重新渲染的时候不需要再为静态节点创建新节点了</li><li>在 Virtual DOM 中的 patch 可以直接跳过（不会改变就没有必要 patch 了）</li></ol><p>优化器的实现原理主要分两部分</p><ol><li>第一步：用递归的方式将所有的节点添加<code>static</code>属性，标识是不是静态节点</li><li>第二步：标记所有的静态根节点</li></ol><p>什么是静态根节点？？</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>我是静态节点1，我不需要发生变化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>我是静态节点2，我不需要发生变化<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>ul 就是静态根节点。</p><p>做完了优化的过程之后，就会改每个 AST 树上的每一个元素打上标记<code>static</code>和<code>staticRoot</code>，这会运行时对模板的更新起到了极大的优化作用，会影响接下来执行代码生成的过程。</p>',11),v=(0,p.Uk)("详细的过程参考: "),f={href:"https://ustbhuangyi.github.io/vue-analysis/v2/compile/optimize.htm",target:"_blank",rel:"noopener noreferrer"},j=(0,p.Uk)("Vue.js 技术揭秘-optimize"),w=(0,p.uE)('<h3 id="生成代码" tabindex="-1"><a class="header-anchor" href="#生成代码" aria-hidden="true">#</a> 生成代码</h3><p>代码生成器的作用是使用 <code>elemen ASTs</code> 生成 <code>render</code> 函数代码字符串。</p><p>如：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Berwin<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>c<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>模板生成后的 AST 后生成 render 后是这样的：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">with</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span>\n    <span class="token string">&quot;p&quot;</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      attrs<span class="token operator">:</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">&quot;Berwin&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      on<span class="token operator">:</span> <span class="token punctuation">{</span> click<span class="token operator">:</span> c <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li><code>_c</code>是<code>createElement</code>可以创建一个元素。</li><li><code>_v</code> 是<code>createTextVNode</code>的意思是创建一个文本节点。</li><li><code>_s</code> 是<code>toString</code>返回参数中的字符串。</li></ul><p>代码生成器的逻辑其实就是使用<code>element ASTs</code>去递归，然后拼出<code>_c(&#39;div&#39;,[_c(&#39;p&#39;,[_v(_s(name))])])</code>的字符串，最后传给<code>render</code></p><p>那如何拼出的这个字符串呢？</p><p>看下边的代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">genElement</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token operator">:</span> ASTElement<span class="token punctuation">,</span> state<span class="token operator">:</span> CodegenState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> el<span class="token punctuation">.</span>plain <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> <span class="token function">genData</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> children <span class="token operator">=</span> el<span class="token punctuation">.</span>inlineTemplate <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">genChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">let</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_c(&#39;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>el<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&#39;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>\n    data <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// data</span>\n  <span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>\n    children <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>children<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// children</span>\n  <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n\n  <span class="token keyword">return</span> code<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>重点是<code>code</code>的生成逻辑，<code>_c</code>（createElement）函数接受三个参数: <code>tabName</code>，<code>data</code>，<code>children</code>。</p><p>所以上面的逻辑就是用 genData 和 genChiildren 获取 data 和 children 然后拼到<code>_c</code>中，然后把拼好的<code>_c(tagName, data, children)</code>返回。</p><p>所以，两个问题：</p><ol><li>data 如何生成的(genData 的逻辑)</li><li>children 如何生成的（genChildren 逻辑）</li></ol><ul><li>genData 逻辑：主要靠判断不同的标签类别去生成不同的 data</li><li>genChildren 逻辑：递归加判断</li></ul><p>最后将生成的 code 装入 with 中。</p><p>至于为什么将代码放入<code>with(this){..}</code>中，其实是为了方便取值，先看它的使用方法：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&quot;tom&quot;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// tom</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li><p>with 的 优点： 当 with 传入的值非常复杂时，即当 object 为非常复杂的嵌套结构时，with 就使得代码显得非常简洁。</p></li><li><p>with 的缺点： js 的编译器会检测 with 块中的变量是否属于 with 传入的对象， 上述例子为例，js 会检测 a 和 b 是否属于 obj 对象，这样就会的导致 with 语句的执行速度大大下降，性能比较差。</p></li></ul><p>但是总体来看是优化了代码的结构，所以还是利大于弊的。</p>',21),_=(0,p.Uk)("具体的参考:"),y={href:"https://ustbhuangyi.github.io/vue-analysis/v2/compile/codegen.html#generate",target:"_blank",rel:"noopener noreferrer"},q=(0,p.Uk)("Vue 技术揭秘-codeGen"),E=(0,p.uE)('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>从<code>.vue</code>文件是怎么编译为<code>.js</code>文件问题引出，到分析 Vue 模板的三个部分：解析器（parser）,优化器（optimalzer）和代码生成器（code generator）。</p><ul><li>解析器：将<code>模板字符串</code>转换成<code>element ASTs</code></li><li>优化器：将<code>ASTs</code> 打上标记，区分静态节点和静态根节点</li><li>代码生成器：将<code>ASTs</code>生成 <code>render</code> 函数代码</li><li>渲染：最后 <code>render</code> 会使用<code>createElement</code>可返回一个 VNode</li><li>VNode：在经过 <code>patch</code> 过程后生成真实的 DOM</li></ul><p><img src="https://i.loli.net/2021/07/20/wQ18raW7I3JytKu.png" alt=""></p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',5),V={href:"https://ustbhuangyi.github.io/vue-analysis/v2/prepare/build.html#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"},x=(0,p.Uk)("Vue 技术揭秘"),A={href:"https://vue-loader.vuejs.org/zh/guide/#vue-cli",target:"_blank",rel:"noopener noreferrer"},U=(0,p.Uk)("Vue loader"),S={href:"https://juejin.cn/post/6863241580753616903",target:"_blank",rel:"noopener noreferrer"},B=(0,p.Uk)("Vue 模板编译原理"),T={href:"https://blog.csdn.net/wang729506596/article/details/90947583",target:"_blank",rel:"noopener noreferrer"},C=(0,p.Uk)("vue 底层-template 模板编译"),D={href:"https://juejin.cn/post/6844903576343412743",target:"_blank",rel:"noopener noreferrer"},W=(0,p.Uk)("Vue 模板解析"),M={render:function(n,s){const a=(0,p.up)("OutboundLink");return(0,p.wg)(),(0,p.iD)(p.HY,null,[e,(0,p._)("p",null,[t,(0,p._)("a",o,[l,(0,p.Wm)(a)]),c]),u,(0,p._)("p",null,[i,(0,p._)("a",r,[k,(0,p.Wm)(a)]),d]),(0,p._)("p",null,[b,(0,p._)("a",m,[g,(0,p.Wm)(a)])]),h,(0,p._)("p",null,[v,(0,p._)("a",f,[j,(0,p.Wm)(a)])]),w,(0,p._)("p",null,[_,(0,p._)("a",y,[q,(0,p.Wm)(a)])]),E,(0,p._)("ul",null,[(0,p._)("li",null,[(0,p._)("a",V,[x,(0,p.Wm)(a)])]),(0,p._)("li",null,[(0,p._)("a",A,[U,(0,p.Wm)(a)])]),(0,p._)("li",null,[(0,p._)("a",S,[B,(0,p.Wm)(a)])]),(0,p._)("li",null,[(0,p._)("a",T,[C,(0,p.Wm)(a)])]),(0,p._)("li",null,[(0,p._)("a",D,[W,(0,p.Wm)(a)])])])],64)}}}}]);