"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5464],{8685:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-4314ed61",path:"/articles/JavaScript/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.html",title:"",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"函数参数传递",slug:"函数参数传递",children:[]},{level:2,title:"基础类型传参",slug:"基础类型传参",children:[]},{level:2,title:"引用类型传参",slug:"引用类型传参",children:[]},{level:2,title:"总结",slug:"总结",children:[]},{level:2,title:"参考",slug:"参考",children:[]}],filePathRelative:"articles/JavaScript/函数参数传递.md",git:{}}},6230:(n,s,a)=>{a.r(s),a.d(s,{default:()=>l});var p=a(6252);const e=(0,p.uE)('<h2 id="函数参数传递" tabindex="-1"><a class="header-anchor" href="#函数参数传递" aria-hidden="true">#</a> 函数参数传递</h2><p>在 JavaScript 中函数传参，分为两种：</p><ul><li>基础类型（Number、String、Boolean..）</li><li>引用类型（Object、Array、Funcion..）</li></ul><h2 id="基础类型传参" tabindex="-1"><a class="header-anchor" href="#基础类型传参" aria-hidden="true">#</a> 基础类型传参</h2><p>看下面的例子：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    prop <span class="token operator">=</span> <span class="token number">1</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment">// 1</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment">// 0</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>比较好理解，其实就是复制了一个值传入了函数中，复制的值修改了，原值不会修改。</p><h2 id="引用类型传参" tabindex="-1"><a class="header-anchor" href="#引用类型传参" aria-hidden="true">#</a> 引用类型传参</h2><p>看例子：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    prop<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">// { value: 1 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">// { value: 1 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>给函数传了一个对象进去，然后在对象中修改属性的值，会导致原值的属性也被修改。 其实传入函数的是复制的一个对象的内存引用地址，修改对象的属性是通过复制的内存地址找到的这个对象，然后修改的是原对象上的属性。</p><p>如果将传过来的的引用地址在重新复制，是可以的：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>\n<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    prop <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">// { value: 1 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">// { value: 0 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>将复制的引用地址 重新赋值一个新的对象，则当前赋值的这个对象（1）和传进的对象（0）就毫无关系了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>所以，对于函数的参数传递，普通类型传递的是值的副本，而引用类型传递的是引用地址的副本。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',17),t={href:"https://github.com/mqyqingfeng/Blog/issues/10",target:"_blank",rel:"noopener noreferrer"},o=(0,p.Uk)("JavaScript 深入之参数按值传递"),l={render:function(n,s){const a=(0,p.up)("OutboundLink");return(0,p.wg)(),(0,p.iD)(p.HY,null,[e,(0,p._)("ul",null,[(0,p._)("li",null,[(0,p._)("a",t,[o,(0,p.Wm)(a)])])])],64)}}}}]);